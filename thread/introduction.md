## 1. 并发简史



## 2. 线程优势



## 3. 线程风险

### 3.1 安全性问题

线程在没有充足的同步情况下，多个线程的操作执行顺序是不可预测的，会产生奇怪的结果。

对于`UnsafeSequence`来说，在多线程的情况下，当执行时机不对时，两个线程在调用`getNext`时可能会得到相同的值：

```java
public class UnsafeSequence {

    private int value;

    /* 返回一个唯一的数值 */
    public int getNext() {
        return value++;
    }
}
```

原因是`value++`操作包括了三个独立的操作：

- 读取`value`值
- 将`value`的值加1
- 将计算的结果写入`value`

因此当多个线程交替执行时，两个线程可能同时执行读操作，并得到相同的值。对于该例子来说，**线程非安全性的结果就是，在不同线程的调用中返回了相同的数值**。

该例子表现了一种常见的并发安全问题，称为**竞态条件（Race Condition）**。可以添加`synchronized`关键字来实现方法的同步：

```java
public class Sequence {

    private int value;

    public synchronized int getNext() {
        return value++;
    }
}
```

### 3.2 活跃性问题

当某个操作无法继续执行下去时，就会发生活跃问题。

- 在串行程序中，形式之一为**无意中造成的无限循环**。
- 在多线程中，形式为**死锁、饥饿、以及活锁**。

### 3.3 性能问题

在多线程程序中不仅包含单线程程序相同的性能问题，还存在由于使用线程引入的其他问题：

- 当线程调度器临时挂起活跃并转而运行另一个线程时，就会**频繁地出现上下文切换操作**。
- 当线程共享数据时，必须使用同步机制，**而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量**。